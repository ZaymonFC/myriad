[{"uri":"https://moiraesoftware.github.io/myriad//index.html","title":"Myriad Overview","content":"\r\n# Myriad\r\n\r\nMyriad is a code generator, put plainly it takes an abstract syntax tree from a source and uses that to produce F# code.\r\n\r\nMyriad can be used from either an MSBuild extension or from its CLI tool.\r\n\r\nThe idea behind Myriad is to un-complicate, as far as possible, the ability to generate and do meta-programming in F#. By meta-programming in F# I mean generating actual F# code like discriminated unions and records, not just IL output.\r\n\r\nMyriad is an evolution of the ideas I developed while working with F#'s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvement that would be a long time to be developed and released.  The idea is you write a Myriad plugin that works on a fragment of AST input, and the plugin supplies AST output with the final form being source code that is built into your project.  Thus the compiler can optimise and tooling can operate effectively too."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/du-extensions.html","title":"DU Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.DuCases>]\r\ntype Currency =\r\n    | CAD\r\n    | PLN\r\n    | EUR\r\n    | USD\r\n    | Custom of string\r\n\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only want the fields plugin to operate on `Currency` then the attribute would be used like in the example about to only apply `Generator.DuCases` to `Currency`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec Test\r\n\r\nmodule Currency =\r\n    open Input\r\n\r\n    let toString (x: Currency) =\r\n        match x with\r\n        | CAD -> \"CAD\"\r\n        | PLN -> \"PLN\"\r\n        | EUR -> \"EUR\"\r\n        | USD -> \"USD\"\r\n        | Custom _ -> \"Custom\"\r\n\r\n    let fromString (x: string) =\r\n        match x with\r\n        | \"CAD\" -> Some CAD\r\n        | \"PLN\" -> Some PLN\r\n        | \"EUR\" -> Some EUR\r\n        | \"USD\" -> Some USD\r\n        | _ -> None\r\n\r\n    let toTag (x: Currency) =\r\n        match x with\r\n        | CAD -> 0\r\n        | PLN -> 1\r\n        | EUR -> 2\r\n        | USD -> 3\r\n        | Custom _ -> 4\r\n\r\n    let isCAD (x: Currency) =\r\n        match x with\r\n        | CAD -> true\r\n        | _ -> false\r\n\r\n    let isPLN (x: Currency) =\r\n        match x with\r\n        | PLN -> true\r\n        | _ -> false\r\n\r\n    let isEUR (x: Currency) =\r\n        match x with\r\n        | EUR -> true\r\n        | _ -> false\r\n\r\n    let isUSD (x: Currency) =\r\n        match x with\r\n        | USD -> true\r\n        | _ -> false\r\n\r\n    let isCustom (x: Currency) =\r\n        match x with\r\n        | Custom _ -> true\r\n        | _ -> false\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/lenses.html","title":"Lenses","content":"\r\n# Lenses\r\n\r\nMyriad can also generate [lenses](https://fsprojects.github.io/FSharpPlus/tutorial.html#Lens) for records and single-case discriminated unions.\r\nLens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\r\n\r\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with `Generator.Lenses` attribute:\r\n\r\n```fsharp\r\n[<Generator.Lenses>]\r\ntype Record =\r\n    { one: int\r\n      two: string }\r\n```\r\n\r\nMyriad will generate the following code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })\r\n    let two = (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })\r\n```\r\n\r\nOften lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU's constructor.\r\n\r\nTo achieve this, decorate your type with the `Lens` attribute, specifying the name of the DU constructor: `[<Generator.Lenses(\"Lens\")>]`, and Myriad will generate this code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = Lens((fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value }))\r\n    let two = Lens((fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value }))\r\n```\r\n\r\nYou can provide the name of DU constructor in several ways:\r\n- As a string: `[<Generator.Lenses(\"Lens\")>]`;\r\n- Or as a type: `[<Generator.Lenses(typedefof<Lens<_, _>>)>]` or `[<Generator.Lenses(typeof<Lens<_, _>>)>]`.\r\n\r\nIf the `Lens` type is in different namespace/module than the type decorated with the attribute, provide the full name of the `Lens` constructor: `[<Generator.Lenses(\"Namespace.And.Module.Of.Lens\")>]`."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/record-fields.html","title":"Record Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.Fields>]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\ntype Test2 = { one: Test1; two: string }\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only want the fields plugin to operate on `Test1` then the attribute would be used like in the example about to only apply `Generator.Fields` to `Test1`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec Test\r\n\r\nmodule Test1 =\r\n    open Example\r\n\r\n    let one (x : Test1) = x.one\r\n    let two (x : Test1) = x.two\r\n    let three (x : Test1) = x.three\r\n    let four (x : Test1) = x.four\r\n\r\n    let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 =\r\n        { one = one\r\n          two = two\r\n          three = three\r\n          four = four }\r\n\r\n    let map (mapone : int -> int) (maptwo : string -> string) (mapthree : float -> float) (mapfour : float32 -> float32) (record': Test1) =\r\n      { record' with\r\n          one = mapone record'.one\r\n          two = maptwo record'.two\r\n          three = mapthree record'.three\r\n          four = mapfour record'.four }\r\n```\r\n\r\nThe fields plugin generates a `map` for each field in the input record, a `create` function taking each field, and a `map` function that takes one function per field in the input record.\r\n\r\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\r\n```fsharp\r\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f}\r\n               {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}]\r\n records |> List.sortBy Test1.one\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/debugging.html","title":"Debugging","content":"\r\n# Debugging\r\n\r\nTo debug Myriad, you can use the following two command line options:\r\n\r\n* `--verbose` — write diagnostic logs out to standard out\r\n* `--wait-for-debugger` — causes Myriad to wait for a debugger to attach to the Myriad process\r\n\r\nThese can be triggered from msbuild by the `<MyriadSdkVerboseOutput>true</MyriadSdkVerboseOutput>` and `<MyriadSdkWaitForDebugger>true</MyriadSdkWaitForDebugger>` properties, respectively."},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/external-plugins.html","title":"External Plugins","content":"\r\n# Using external plugins\r\n\r\nTo consume external plugins that aren't included in the `Myriad.Plugins` package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the `--plugin <path to dll>` command-line argument. If you are using MSBuild then this can be done by adding to the `MyriadSdkGenerator` property to your project file:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <MyriadSdkGenerator Include=\"<path to plugin dll>\" />\r\n</ItemGroup>\r\n```\r\n\r\nFor example, if you had a project layout like this:\r\n\r\n```\r\n\\src\r\n-\\GeneratorLib\r\n - Generator.fs\r\n - Generator.fsproj\r\n-\\GeneratorTests\r\n - Tests.fs\r\n - GeneratorTests.fsproj\r\n```\r\n\r\nYou would add the following to Generator.fsproj:\r\n```xml\r\n  <ItemGroup>\r\n    <Content Include=\"build\\Generator.props\">\r\n      <Pack>true</Pack>\r\n      <PackagePath>%(Identity)</PackagePath>\r\n      <Visible>true</Visible>\r\n    </Content>\r\n  </ItemGroup>\r\n```\r\n\r\nThen add a new folder `build` with the `Generator.props` file within:\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nOften an additional props file (In this smaple the file would be `Generator.InTest.props`) is used to make testing easier.  The matching element for the tests fsproj would be something like this:\r\n\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nNotice the Include path is pointing locally rather than within the packaged nuget folder structure.\r\n\r\nIn your testing `fsproj` you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\r\n\r\n```xml\r\n<!-- include plugin -->\r\n<Import Project=\"<Path to Generator plugin location>\\build\\Myriad.Plugins.InTest.props\" />\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/msbuild-usage.html","title":"MSBuild usage","content":"\r\n# MSBuild usage\r\n\r\nPlugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\r\n\r\nTo use Myriad via its MSBuild support you add the `Myriad.Core` and `Myriad.Sdk` package references:\r\n```xml\r\n    <ItemGroup>\r\n      <PackageReference Include=\"Myriad.Core\" Version=\"0.2.4\" />\r\n      <PackageReference Include=\"Myriad.Sdk\" Version=\"0.2.4\" />\r\n      <PackageReference Include=\"Myriad.Plugins\" Version=\"0.2.4\" /> <!-- Built in set of plugins -->\r\n    </ItemGroup>\r\n```\r\n\r\nAn input file is specified by using the usual `Compile` element:\r\n```xml\r\n<Compile Include=\"Generated.fs\">\r\n    <MyriadFile>Library.fs</MyriadFile>\r\n    <MyriadNameSpace>Test</MyriadNameSpace>\r\n</Compile>\r\n```\r\n\r\nThis is configuring Myriad so that a file called `Generated.fs` will be included in the build using `Library.fs` as input to the Myriad and `Test` as the namespace.\r\n\r\nMyriad works by using plugins to generate code.  A plugin called fields is included with Myriad which takes inspiration from OCamls [ppx_fields_conv](https://github.com/janestreet/ppx_fields_conv) plugin of the same name.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//index.html","title":"Myriad Overview","content":"\r\n# Myriad\r\n\r\nMyriad is a code generator, put plainly it takes an abstract syntax tree from a source and uses that to produce F# code.\r\n\r\nMyriad can be used from either an MSBuild extension or from its CLI tool.\r\n\r\nThe idea behind Myriad is to un-complicate, as far as possible, the ability to generate and do meta-programming in F#. By meta-programming in F# I mean generating actual F# code like discriminated unions and records, not just IL output.\r\n\r\nMyriad is an evolution of the ideas I developed while working with F#'s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvement that would be a long time to be developed and released.  The idea is you write a Myriad plugin that works on a fragment of AST input, and the plugin supplies AST output with the final form being source code that is built into your project.  Thus the compiler can optimise and tooling can operate effectively too."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/du-extensions.html","title":"DU Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.DuCases>]\r\ntype Currency =\r\n    | CAD\r\n    | PLN\r\n    | EUR\r\n    | USD\r\n    | Custom of string\r\n\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only want the fields plugin to operate on `Currency` then the attribute would be used like in the example about to only apply `Generator.DuCases` to `Currency`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec Test\r\n\r\nmodule Currency =\r\n    open Input\r\n\r\n    let toString (x: Currency) =\r\n        match x with\r\n        | CAD -> \"CAD\"\r\n        | PLN -> \"PLN\"\r\n        | EUR -> \"EUR\"\r\n        | USD -> \"USD\"\r\n        | Custom _ -> \"Custom\"\r\n\r\n    let fromString (x: string) =\r\n        match x with\r\n        | \"CAD\" -> Some CAD\r\n        | \"PLN\" -> Some PLN\r\n        | \"EUR\" -> Some EUR\r\n        | \"USD\" -> Some USD\r\n        | _ -> None\r\n\r\n    let toTag (x: Currency) =\r\n        match x with\r\n        | CAD -> 0\r\n        | PLN -> 1\r\n        | EUR -> 2\r\n        | USD -> 3\r\n        | Custom _ -> 4\r\n\r\n    let isCAD (x: Currency) =\r\n        match x with\r\n        | CAD -> true\r\n        | _ -> false\r\n\r\n    let isPLN (x: Currency) =\r\n        match x with\r\n        | PLN -> true\r\n        | _ -> false\r\n\r\n    let isEUR (x: Currency) =\r\n        match x with\r\n        | EUR -> true\r\n        | _ -> false\r\n\r\n    let isUSD (x: Currency) =\r\n        match x with\r\n        | USD -> true\r\n        | _ -> false\r\n\r\n    let isCustom (x: Currency) =\r\n        match x with\r\n        | Custom _ -> true\r\n        | _ -> false\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/lenses.html","title":"Lenses","content":"\r\n# Lenses\r\n\r\nMyriad can also generate [lenses](https://fsprojects.github.io/FSharpPlus/tutorial.html#Lens) for records and single-case discriminated unions.\r\nLens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\r\n\r\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with `Generator.Lenses` attribute:\r\n\r\n```fsharp\r\n[<Generator.Lenses>]\r\ntype Record =\r\n    { one: int\r\n      two: string }\r\n```\r\n\r\nMyriad will generate the following code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })\r\n    let two = (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })\r\n```\r\n\r\nOften lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU's constructor.\r\n\r\nTo achieve this, decorate your type with the `Lens` attribute, specifying the name of the DU constructor: `[<Generator.Lenses(\"Lens\")>]`, and Myriad will generate this code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = Lens((fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value }))\r\n    let two = Lens((fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value }))\r\n```\r\n\r\nYou can provide the name of DU constructor in several ways:\r\n- As a string: `[<Generator.Lenses(\"Lens\")>]`;\r\n- Or as a type: `[<Generator.Lenses(typedefof<Lens<_, _>>)>]` or `[<Generator.Lenses(typeof<Lens<_, _>>)>]`.\r\n\r\nIf the `Lens` type is in different namespace/module than the type decorated with the attribute, provide the full name of the `Lens` constructor: `[<Generator.Lenses(\"Namespace.And.Module.Of.Lens\")>]`."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/record-fields.html","title":"Record Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.Fields>]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\ntype Test2 = { one: Test1; two: string }\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only want the fields plugin to operate on `Test1` then the attribute would be used like in the example about to only apply `Generator.Fields` to `Test1`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec Test\r\n\r\nmodule Test1 =\r\n    open Example\r\n\r\n    let one (x : Test1) = x.one\r\n    let two (x : Test1) = x.two\r\n    let three (x : Test1) = x.three\r\n    let four (x : Test1) = x.four\r\n\r\n    let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 =\r\n        { one = one\r\n          two = two\r\n          three = three\r\n          four = four }\r\n\r\n    let map (mapone : int -> int) (maptwo : string -> string) (mapthree : float -> float) (mapfour : float32 -> float32) (record': Test1) =\r\n      { record' with\r\n          one = mapone record'.one\r\n          two = maptwo record'.two\r\n          three = mapthree record'.three\r\n          four = mapfour record'.four }\r\n```\r\n\r\nThe fields plugin generates a `map` for each field in the input record, a `create` function taking each field, and a `map` function that takes one function per field in the input record.\r\n\r\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\r\n```fsharp\r\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f}\r\n               {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}]\r\n records |> List.sortBy Test1.one\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/debugging.html","title":"Debugging","content":"\r\n# Debugging\r\n\r\nTo debug Myriad, you can use the following two command line options:\r\n\r\n* `--verbose` — write diagnostic logs out to standard out\r\n* `--wait-for-debugger` — causes Myriad to wait for a debugger to attach to the Myriad process\r\n\r\nThese can be triggered from msbuild by the `<MyriadSdkVerboseOutput>true</MyriadSdkVerboseOutput>` and `<MyriadSdkWaitForDebugger>true</MyriadSdkWaitForDebugger>` properties, respectively."},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/external-plugins.html","title":"External Plugins","content":"\r\n# Using external plugins\r\n\r\nTo consume external plugins that aren't included in the `Myriad.Plugins` package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the `--plugin <path to dll>` command-line argument. If you are using MSBuild then this can be done by adding to the `MyriadSdkGenerator` property to your project file:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <MyriadSdkGenerator Include=\"<path to plugin dll>\" />\r\n</ItemGroup>\r\n```\r\n\r\nFor example, if you had a project layout like this:\r\n\r\n```\r\n\\src\r\n-\\GeneratorLib\r\n - Generator.fs\r\n - Generator.fsproj\r\n-\\GeneratorTests\r\n - Tests.fs\r\n - GeneratorTests.fsproj\r\n```\r\n\r\nYou would add the following to Generator.fsproj:\r\n```xml\r\n  <ItemGroup>\r\n    <Content Include=\"build\\Generator.props\">\r\n      <Pack>true</Pack>\r\n      <PackagePath>%(Identity)</PackagePath>\r\n      <Visible>true</Visible>\r\n    </Content>\r\n  </ItemGroup>\r\n```\r\n\r\nThen add a new folder `build` with the `Generator.props` file within:\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nOften an additional props file (In this smaple the file would be `Generator.InTest.props`) is used to make testing easier.  The matching element for the tests fsproj would be something like this:\r\n\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nNotice the Include path is pointing locally rather than within the packaged nuget folder structure.\r\n\r\nIn your testing `fsproj` you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\r\n\r\n```xml\r\n<!-- include plugin -->\r\n<Import Project=\"<Path to Generator plugin location>\\build\\Myriad.Plugins.InTest.props\" />\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/msbuild-usage.html","title":"MSBuild usage","content":"\r\n# MSBuild usage\r\n\r\nPlugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\r\n\r\nTo use Myriad via its MSBuild support you add the `Myriad.Core` and `Myriad.Sdk` package references:\r\n```xml\r\n    <ItemGroup>\r\n      <PackageReference Include=\"Myriad.Core\" Version=\"0.2.4\" />\r\n      <PackageReference Include=\"Myriad.Sdk\" Version=\"0.2.4\" />\r\n      <PackageReference Include=\"Myriad.Plugins\" Version=\"0.2.4\" /> <!-- Built in set of plugins -->\r\n    </ItemGroup>\r\n```\r\n\r\nAn input file is specified by using the usual `Compile` element:\r\n```xml\r\n<Compile Include=\"Generated.fs\">\r\n    <MyriadFile>Library.fs</MyriadFile>\r\n    <MyriadNameSpace>Test</MyriadNameSpace>\r\n</Compile>\r\n```\r\n\r\nThis is configuring Myriad so that a file called `Generated.fs` will be included in the build using `Library.fs` as input to the Myriad and `Test` as the namespace.\r\n\r\nMyriad works by using plugins to generate code.  A plugin called fields is included with Myriad which takes inspiration from OCamls [ppx_fields_conv](https://github.com/janestreet/ppx_fields_conv) plugin of the same name.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/index.html","title":"Myriad.Core - API Reference","content":"Myriad.Core \n Myriad.Core"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-ast.html","title":"Ast","content":"Ast \n  \n  \n  \n fromFilename  typeNameMatches  hasAttributeWithConst  extractTypeDefn  isRecord  isDu  extractRecords  extractDU  hasAttributeWithName  hasAttribute  getAttribute  \n "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-imyriadgenerator.html","title":"IMyriadGenerator","content":"IMyriadGenerator \n  \n Generate "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-myriadgeneratorattribute.html","title":"MyriadGeneratorAttribute","content":"MyriadGeneratorAttribute \n  \n ( .ctor )  Name "},{"uri":"https://moiraesoftware.github.io/myriad//index.html","title":"Myriad Overview","content":"\r\n# Myriad\r\n\r\nMyriad is a code generator, put plainly it takes an abstract syntax tree from a source and uses that to produce F# code.\r\n\r\nMyriad can be used from either an MSBuild extension or from its CLI tool.\r\n\r\nThe idea behind Myriad is to un-complicate, as far as possible, the ability to generate and do meta-programming in F#. By meta-programming in F# I mean generating actual F# code like discriminated unions and records, not just IL output.\r\n\r\nMyriad is an evolution of the ideas I developed while working with F#'s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvement that would be a long time to be developed and released.  The idea is you write a Myriad plugin that works on a fragment of AST input, and the plugin supplies AST output with the final form being source code that is built into your project.  Thus the compiler can optimise and tooling can operate effectively too."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/du-extensions.html","title":"DU Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.DuCases>]\r\ntype Currency =\r\n    | CAD\r\n    | PLN\r\n    | EUR\r\n    | USD\r\n    | Custom of string\r\n\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only want the fields plugin to operate on `Currency` then the attribute would be used like in the example about to only apply `Generator.DuCases` to `Currency`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec Test\r\n\r\nmodule Currency =\r\n    open Input\r\n\r\n    let toString (x: Currency) =\r\n        match x with\r\n        | CAD -> \"CAD\"\r\n        | PLN -> \"PLN\"\r\n        | EUR -> \"EUR\"\r\n        | USD -> \"USD\"\r\n        | Custom _ -> \"Custom\"\r\n\r\n    let fromString (x: string) =\r\n        match x with\r\n        | \"CAD\" -> Some CAD\r\n        | \"PLN\" -> Some PLN\r\n        | \"EUR\" -> Some EUR\r\n        | \"USD\" -> Some USD\r\n        | _ -> None\r\n\r\n    let toTag (x: Currency) =\r\n        match x with\r\n        | CAD -> 0\r\n        | PLN -> 1\r\n        | EUR -> 2\r\n        | USD -> 3\r\n        | Custom _ -> 4\r\n\r\n    let isCAD (x: Currency) =\r\n        match x with\r\n        | CAD -> true\r\n        | _ -> false\r\n\r\n    let isPLN (x: Currency) =\r\n        match x with\r\n        | PLN -> true\r\n        | _ -> false\r\n\r\n    let isEUR (x: Currency) =\r\n        match x with\r\n        | EUR -> true\r\n        | _ -> false\r\n\r\n    let isUSD (x: Currency) =\r\n        match x with\r\n        | USD -> true\r\n        | _ -> false\r\n\r\n    let isCustom (x: Currency) =\r\n        match x with\r\n        | Custom _ -> true\r\n        | _ -> false\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/lenses.html","title":"Lenses","content":"\r\n# Lenses\r\n\r\nMyriad can also generate [lenses](https://fsprojects.github.io/FSharpPlus/tutorial.html#Lens) for records and single-case discriminated unions.\r\nLens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\r\n\r\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with `Generator.Lenses` attribute:\r\n\r\n```fsharp\r\n[<Generator.Lenses>]\r\ntype Record =\r\n    { one: int\r\n      two: string }\r\n```\r\n\r\nMyriad will generate the following code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })\r\n    let two = (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })\r\n```\r\n\r\nOften lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU's constructor.\r\n\r\nTo achieve this, decorate your type with the `Lens` attribute, specifying the name of the DU constructor: `[<Generator.Lenses(\"Lens\")>]`, and Myriad will generate this code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = Lens((fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value }))\r\n    let two = Lens((fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value }))\r\n```\r\n\r\nYou can provide the name of DU constructor in several ways:\r\n- As a string: `[<Generator.Lenses(\"Lens\")>]`;\r\n- Or as a type: `[<Generator.Lenses(typedefof<Lens<_, _>>)>]` or `[<Generator.Lenses(typeof<Lens<_, _>>)>]`.\r\n\r\nIf the `Lens` type is in different namespace/module than the type decorated with the attribute, provide the full name of the `Lens` constructor: `[<Generator.Lenses(\"Namespace.And.Module.Of.Lens\")>]`."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/record-fields.html","title":"Record Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.Fields>]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\ntype Test2 = { one: Test1; two: string }\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only want the fields plugin to operate on `Test1` then the attribute would be used like in the example about to only apply `Generator.Fields` to `Test1`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec Test\r\n\r\nmodule Test1 =\r\n    open Example\r\n\r\n    let one (x : Test1) = x.one\r\n    let two (x : Test1) = x.two\r\n    let three (x : Test1) = x.three\r\n    let four (x : Test1) = x.four\r\n\r\n    let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 =\r\n        { one = one\r\n          two = two\r\n          three = three\r\n          four = four }\r\n\r\n    let map (mapone : int -> int) (maptwo : string -> string) (mapthree : float -> float) (mapfour : float32 -> float32) (record': Test1) =\r\n      { record' with\r\n          one = mapone record'.one\r\n          two = maptwo record'.two\r\n          three = mapthree record'.three\r\n          four = mapfour record'.four }\r\n```\r\n\r\nThe fields plugin generates a `map` for each field in the input record, a `create` function taking each field, and a `map` function that takes one function per field in the input record.\r\n\r\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\r\n```fsharp\r\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f}\r\n               {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}]\r\n records |> List.sortBy Test1.one\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/debugging.html","title":"Debugging","content":"\r\n# Debugging\r\n\r\nTo debug Myriad, you can use the following two command line options:\r\n\r\n* `--verbose` — write diagnostic logs out to standard out\r\n* `--wait-for-debugger` — causes Myriad to wait for a debugger to attach to the Myriad process\r\n\r\nThese can be triggered from msbuild by the `<MyriadSdkVerboseOutput>true</MyriadSdkVerboseOutput>` and `<MyriadSdkWaitForDebugger>true</MyriadSdkWaitForDebugger>` properties, respectively."},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/external-plugins.html","title":"External Plugins","content":"\r\n# Using external plugins\r\n\r\nTo consume external plugins that aren't included in the `Myriad.Plugins` package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the `--plugin <path to dll>` command-line argument. If you are using MSBuild then this can be done by adding to the `MyriadSdkGenerator` property to your project file:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <MyriadSdkGenerator Include=\"<path to plugin dll>\" />\r\n</ItemGroup>\r\n```\r\n\r\nFor example, if you had a project layout like this:\r\n\r\n```\r\n\\src\r\n-\\GeneratorLib\r\n - Generator.fs\r\n - Generator.fsproj\r\n-\\GeneratorTests\r\n - Tests.fs\r\n - GeneratorTests.fsproj\r\n```\r\n\r\nYou would add the following to Generator.fsproj:\r\n```xml\r\n  <ItemGroup>\r\n    <Content Include=\"build\\Generator.props\">\r\n      <Pack>true</Pack>\r\n      <PackagePath>%(Identity)</PackagePath>\r\n      <Visible>true</Visible>\r\n    </Content>\r\n  </ItemGroup>\r\n```\r\n\r\nThen add a new folder `build` with the `Generator.props` file within:\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nOften an additional props file (In this smaple the file would be `Generator.InTest.props`) is used to make testing easier.  The matching element for the tests fsproj would be something like this:\r\n\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nNotice the Include path is pointing locally rather than within the packaged nuget folder structure.\r\n\r\nIn your testing `fsproj` you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\r\n\r\n```xml\r\n<!-- include plugin -->\r\n<Import Project=\"<Path to Generator plugin location>\\build\\Myriad.Plugins.InTest.props\" />\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/msbuild-usage.html","title":"MSBuild usage","content":"\r\n# MSBuild usage\r\n\r\nPlugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\r\n\r\nTo use Myriad via its MSBuild support you add the `Myriad.Core` and `Myriad.Sdk` package references:\r\n```xml\r\n    <ItemGroup>\r\n      <PackageReference Include=\"Myriad.Core\" Version=\"0.2.4\" />\r\n      <PackageReference Include=\"Myriad.Sdk\" Version=\"0.2.4\" />\r\n      <PackageReference Include=\"Myriad.Plugins\" Version=\"0.2.4\" /> <!-- Built in set of plugins -->\r\n    </ItemGroup>\r\n```\r\n\r\nAn input file is specified by using the usual `Compile` element:\r\n```xml\r\n<Compile Include=\"Generated.fs\">\r\n    <MyriadFile>Library.fs</MyriadFile>\r\n    <MyriadNameSpace>Test</MyriadNameSpace>\r\n</Compile>\r\n```\r\n\r\nThis is configuring Myriad so that a file called `Generated.fs` will be included in the build using `Library.fs` as input to the Myriad and `Test` as the namespace.\r\n\r\nMyriad works by using plugins to generate code.  A plugin called fields is included with Myriad which takes inspiration from OCamls [ppx_fields_conv](https://github.com/janestreet/ppx_fields_conv) plugin of the same name.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/index.html","title":"Myriad.Plugins - API Reference","content":"Myriad.Plugins \n Myriad.Plugins"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator.html","title":"Generator","content":"Generator \n  \n  \n DuCasesAttribute  FieldsAttribute  LensesAttribute <p>Instructs to generate lenses for each property of the record</p>\r\n\r\n \n  \n "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-ducasesgenerator.html","title":"DUCasesGenerator","content":"DUCasesGenerator \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-fieldsgenerator.html","title":"FieldsGenerator","content":"FieldsGenerator \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-lensesgenerator.html","title":"LensesGenerator","content":"LensesGenerator \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator-ducasesattribute.html","title":"DuCasesAttribute","content":"DuCasesAttribute \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator-fieldsattribute.html","title":"FieldsAttribute","content":"FieldsAttribute \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator-lensesattribute.html","title":"LensesAttribute","content":"LensesAttribute \n <p>Instructs to generate lenses for each property of the record</p>\r\n\r\n \n ( .ctor )  ( .ctor )  ( .ctor )  WrapperName "}]